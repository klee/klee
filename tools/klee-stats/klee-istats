#!/usr/bin/env python
# -*- encoding: utf-8 -*-
"""Output instruction time statistics from an istat file"""

# use '/' to mean true division and '//' to mean floor division
from __future__ import division
from __future__ import print_function

import os
import re
import sys
import argparse

from operator import itemgetter
try:
    from tabulate import TableFormat, Line, DataRow, tabulate
except:
    print('Error: Package "tabulate" required for table formatting. '
          'Please install it using "pip" or your package manager.',
          file=sys.stderr)
    exit(1)

Legend = [
    ('Instrs', 'number of executed instructions'),
    ('Time', 'total wall time (s)'),
    ('TUser', 'total user time'),
    ('ICov', 'instruction coverage in the LLVM bitcode (%)'),
    ('BCov', 'branch coverage in the LLVM bitcode (%)'),
    ('ICount', 'total static instructions in the LLVM bitcode'),
    ('TSolver', 'time spent in the constraint solver'),
    ('TCoreSolver', 'time spent in the core constraint solver'),
    ('States', 'number of currently active states'),
    ('Mem', 'megabytes of memory currently used'),
    ('Queries', 'number of queries issued to STP'),
    ('QueriesF', 'number of queries issued to STP and failed (timeout or STP failures)'),
    ('AvgQC', 'average number of query constructs per query'),
    ('Tcex', 'time spent in the counterexample caching code'),
    ('Tind', 'time spent in the independenet solver'),
    ('Tfork', 'time spent forking'),
    ('TResolve', 'time spent in object resolution'),
    ('TPCS', 'time spent in path constraint simplification'),
]

KleeTable = TableFormat(lineabove=Line("-", "-", "-", "-"),
                        linebelowheader=Line("-", "-", "-", "-"),
                        linebetweenrows=None,
                        linebelow=Line("-", "-", "-", "-"),
                        headerrow=DataRow("|", "|", "|"),
                        datarow=DataRow("|", "|", "|"),
                        padding=0,
                        with_header_hide=None)

class LazyEvalList:
    """Store all the lines in run.stats and eval() when needed."""
    def __init__(self, lines):
        # The first line in the records contains headers.
        self.lines = lines[1:]

    def __getitem__(self, index):
        if isinstance(self.lines[index], str):
            self.lines[index] = eval(self.lines[index])
        return self.lines[index]

    def __len__(self):
        return len(self.lines)


def getMatchedRecordIndex(records, column, target):
    """Find target from the specified column in records."""
    target = int(target)
    lo = 0
    hi = len(records) - 1
    while lo < hi:
        mid = (lo + hi) // 2
        if column(records[mid]) <= target:
            lo = mid + 1
        else:
            hi = mid
    return lo


def aggregateRecords(records):
    # index for memUsage and stateCount in run.stats
    memIndex = 6
    stateIndex = 5

    # maximum and average memory usage
    memValues = list(map(itemgetter(memIndex), records))
    maxMem = max(memValues) / 1024 / 1024
    avgMem = sum(memValues) / len(memValues) / 1024 / 1024

    # maximum and average number of states
    stateValues = list(map(itemgetter(stateIndex), records))
    maxStates = max(stateValues)
    avgStates = sum(stateValues) / len(stateValues)

    return (maxMem, avgMem, maxStates, avgStates)


def stripCommonPathPrefix(paths):
    paths = map(os.path.normpath, paths)
    paths = [p.split('/') for p in paths]
    zipped = zip(*paths)
    i = 0
    for i, elts in enumerate(zipped):
        if len(set(elts)) > 1:
            break
    return ['/'.join(p[i:]) for p in paths]


def getKeyIndex(key, labels):
    """Get the index of the specified key in labels."""
    def normalizeKey(key):
        return re.split('\W', key)[0]

    for i, title in enumerate(labels):
        if normalizeKey(title) == normalizeKey(key):
            return i
    else:
        raise ValueError('invalid key: {0}'.format(key))


def getLabels(pr):
    if pr == 'all':
        labels = ('Mnemonic', 'Time(s)', 'PerInstAvg(ms)', 'PerInstMax(ms)')
    if pr == 'locations':
        labels = ('Time(s)', 'PerInstTime(s)', 'Assembly Line', 'Mnemonic')
    return labels


def getRow(record, stats, pr):
    """Compose data for the current run into a row."""
    I, BFull, BPart, BTot, T, St, Mem, QTot, Qf, QCH, QCM, QCCH, QCCM,\
        QCon, _, Treal, SCov, SUnc, Tq, Ts, Tcex, Tind, Tf, Tr, Tpcs = record
    maxMem, avgMem, maxStates, avgStates = stats

    # special case for straight-line code: report 100% branch coverage
    if BTot == 0:
        BFull = BTot = 1

    Mem = Mem / 1024 / 1024
    AvgQC = int(QCon / max(1, QTot))

    if pr == 'all':
        row = (I, Treal, 100 * SCov / (SCov + SUnc),
               100 * (2 * BFull + BPart) / (2 * BTot), SCov + SUnc,
               100 * Ts / Treal, St, maxStates, avgStates,
               Mem, maxMem, avgMem, QTot, Qf, AvgQC,
               100 * Tcex / Treal, 100 * Tf / Treal, 100 * Tpcs / Treal)
    elif pr == 'reltime':
        row = (Treal, 100 * T / Treal, 100 * Ts / Treal,
               100 * Tcex / Treal, 100 * Tf / Treal,
               100 * Tr / Treal, 100 * Tpcs / Treal)
    elif pr == 'abstime':
        row = (Treal, T, Ts, Tcex, Tf, Tr, Tpcs)
    elif pr == 'more':
        row = (I, Treal, 100 * SCov / (SCov + SUnc),
               100 * (2 * BFull + BPart) / (2 * BTot),
               SCov + SUnc, 100 * Ts / Treal,
               St, maxStates, Mem, maxMem)
    elif pr == 'solver':
        row = (Treal, 100 * Ts / Treal, 100 * Tq / Treal, 100 * Tcex / Treal,
                100 * Tind / Treal, 100 * Tf / Treal, 100 * Tr / Treal,
                100 * Tpcs / Treal, QTot, Qf, QCH, QCM, QCCH, QCCM, AvgQC)
    else:
        row = (I, Treal, 100 * SCov / (SCov + SUnc),
               100 * (2 * BFull + BPart) / (2 * BTot),
               SCov + SUnc, 100 * Ts / Treal)
    return row


def drawLineChart(vectors, titles):
    """Draw a line chart based on data from vectors.

    Args:
        vectors: A list of vectors. Each vector is drawn in a separate
                 subchart.
        titles: A list of strings. Each string is an explanation of the
                corresponding vector.
    """
    try:
        import matplotlib
        matplotlib.use('Agg')  # plot without X-server connection
        import matplotlib.pyplot as plt
    except:
        print('Error: Package "matplotlib" required for figure plotting. '
              'Please install it using "pip" or your package manager.',
              file=sys.stderr)
        exit(1)
    from math import sqrt, ceil

    nFigs = len(vectors)       # number of subfigures
    nRow = int(sqrt(nFigs))    # number of rows in the figure
    nCol = ceil(nFigs / nRow)  # number of columns in the figure

    fig = plt.figure()
    for i in range(nFigs):
        ax = fig.add_subplot(nRow, nCol, i)
        ax.plot(vectors[i])
        ax.set_title(titles[i])
        #ax.set_xlabel()
        #ax.set_ylabel()

    #fig.show()
    #raw_input('Press any key to continue..')

    def getFileName():
        """Get a unused file name in current directory."""
        i = 0
        fileName = 'fig-klee-stats-{0}.png'.format(i)
        while os.path.exists(fileName):
            i = i + 1
            fileName = 'fig-klee-stats-{0}.png'.format(i)
        return fileName

    plt.savefig(getFileName(),
                dpi=150,  # dots-per-inch, default: 100
                bbox_inches='tight',  # tighter bbox
                transparent=False)
def enum(**enums):
    return type('Enum', (), enums)

StatFields = enum(AssemblyLine=0,
              FileLine=1,
              Covered=2,
              Forks=3,
              RealTime=4,
              UserTime=5,
              Instructions=6,
              MDU=7,
              ResolveTime=8,
              States=9,
              Uncovered=10,
              Queries=11)

def parseAssembly(assembly):
    """Parse an LLVM assembly file
    """

    def getInstruction(line):
        inst = ''
        if line.startswith('  '):
            line = line.lstrip()
            if line.startswith('%'):
                _, _, line = line.partition('=')
                line = line.lstrip()
                inst, _, _  = line.partition(' ')
            else:
                inst, _, _ = line.partition(' ')
            if inst == 'tail':
                inst = 'call'
        return inst

    insts = [getInstruction(line) for line in open(assembly)]
    uinsts = [i for i in set(insts) if i]
    ilmap = zip(uinsts, [[l + 1 for l, i in enumerate(insts) if i == ui] for ui in uinsts])
    return ilmap

def parseStats(stats):
    """Parse a klee-generated istats file
    
    """

    def getStats(line):
        stat = (0,(0, 0, 0))
        items = line.split()
        try:
            if len(items) > 4 and items[StatFields.Covered] == '1':
                line = int(items[StatFields.AssemblyLine])
                time = int(items[StatFields.RealTime])
                count = int(items[StatFields.Instructions])
                stat = (line, (time,count,time/count))
        except:
            pass
        return stat

    d = dict([getStats(line) for line in open(stats)])
    if 0 in d:
        del d[0]
    return d

def openLLIstats(cdir):
    assembly = os.path.join(cdir, 'assembly.ll')
    istats   = os.path.join(cdir, 'run.istats')
    if os.path.exists(assembly) and os.path.exists(istats):
        asdata = parseAssembly(assembly)
        stats = parseStats(istats)
    else:
        print('assembly.ll or run.istats no found', file=sys.stderr)
        exit(1)

    return asdata, stats

def topInstructions(cdir):
    asdata, stats = openLLIstats(cdir)
    itimes = []
    #instruction and lines its on
    for inst, lines in asdata:
        statList = []
        for l in lines:
            if l in stats:
                #Add stats for corresponding line
                statList.append(stats[l])
        values = zip(*statList)
        agg = map(sum, values)
        itimes.append((inst, agg))

    # Eliminate bogus instructions picked up by our imperfect LLVM IR parser
    itimes = [item for item in itimes if item[1]]

    validinst = set([item[0] for item in itimes])

    maxitimes = dict([(inst, max([stats[l][2] for l in lines if l in stats])) for inst, lines in asdata if inst in validinst])
    
    # Sort by real time
    itimes.sort(key=lambda x : x[1][0], reverse=True)
    itimes = itimes[:10]

    return maxitimes, itimes

def topLocationsAll(cdir):
    asdata, stats = openLLIstats(cdir)

    linemnemonic = dict([(l, m) for m, lines in asdata for l in lines])
    data = [(stats[line][0]/1000000, stats[line][2]/1000000, line, linemnemonic[line]) for line in stats]
    data.sort(key=lambda x : x[0], reverse=True)

    return data

def topLocations(cdir, TL):
    asdata, stats = openLLIstats(cdir)

    targets = []
    for  m, lines in asdata:
        if m == TL:
            targets = lines
            break
    data = [(stats[line][0]/1000000, stats[line][2]/1000000, line, TL) for line in stats if line in targets]
    data.sort(key=lambda x : x[0], reverse=True)

    return data

def main():
    # function for sanitizing arguments
    def isPositiveInt(value):
        try:
            value = int(value)
        except ValueError:
            raise argparse.ArgumentTypeError(
                'integer expected: {0}'.format(value))
        if value <= 0:
            raise argparse.ArgumentTypeError(
                'positive integer expected: {0}'.format(value))
        return value

    parser = argparse.ArgumentParser(
        description='output instruction time statistics logged by klee',
        epilog='LEGEND\n' + tabulate(Legend),
        formatter_class=argparse.RawDescriptionHelpFormatter)

    parser.add_argument('dir', help='klee output directory')

    parser.add_argument('--precision',
                        dest='precision', type=isPositiveInt,
                        default=2, metavar='n',
                        help='Floating point numbers display precision '
                        '(default: 2).')
    parser.add_argument('--table-format',
                        choices=['plain', 'simple', 'grid', 'pipe', 'orgtbl',
                                 'rst', 'mediawiki', 'latex', 'klee'],
                        dest='tableFormat', default='klee',
                        help='Table format for the summary.')
    parser.add_argument('--draw-line-chart',
                        dest='drawLineChart', metavar='header-list',
                        help='Draw line chart for a list of columns. '
                        'Columns must be chosen from the headers of the '
                        'table outputted and seperated by comma (e.g., '
                        '--draw-line-chart=Instrs,Time). Data points '
                        'on x-axis correspond to lines in run.stats.')

    pControl = parser.add_mutually_exclusive_group(required=True)
    pControl.add_argument('--top-instructions',
                          action='store_true', dest='TI',
                          help='Show most expensive instructions.')
    pControl.add_argument('--top-locations',
                          nargs='?', const='all', default='all', dest='TL',
                          help='Show most expensive locations')

    args = parser.parse_args()

    asdata, stats = openLLIstats(args.dir)

    if args.TI:
        labels = getLabels('all')
        table = [labels]

        maxitimes, itimes = topInstructions(args.dir)

        print(maxitimes['store'])
        table.extend([x[0], x[1][0]/1000000, x[1][0]/x[1][1]/1000, maxitimes[x[0]]/1000] for x in itimes[:10])
    elif args.TL:
        labels = getLabels('locations')
        table = [labels]
        if args.TL == 'all':
            data = topLocationsAll(args.dir)
        else:
            data = topLocations(args.dir, args.TL)
    
        table.extend(data[:30])

    if args.tableFormat != 'klee':
        print(tabulate(
            table, headers='firstrow',
            tablefmt=args.tableFormat,
            floatfmt='.{p}f'.format(p=args.precision),
            numalign='right', stralign='center'))
    else:
        stream = tabulate(
            table, headers='firstrow',
            tablefmt=KleeTable,
            floatfmt='.{p}f'.format(p=args.precision),
            numalign='right', stralign='center')
        print(stream)



    if args.drawLineChart:
        if len(dirs) != 1:
            print('--draw-line-chart only supports using a single file',
                  file=sys.stderr)
            exit(1)

        # sample according to the given interval
        samples = [r for i, r in enumerate(data[0][1])
                   if i % args.sampleInterv == 0]
        vectors = []
        for i in range(len(samples)):
            # aggregate all the samples upto the i-th one
            stats = aggregateRecords(samples[:i + 1])
            vectors.append(getRow(samples[i], stats, pr))

        titles = args.drawLineChart.split(',')
        # Index returned by getKeyIndex() against labels is starting from
        # 'Path' column.  vectors here doesn't have the 'Path' column.
        indices = [getKeyIndex(e, labels) - 1 for e in titles]
        # get one more column to make sure itemgetter always return tuples
        indices.append(0)
        # strip columns not specified by the user
        vectors = map(itemgetter(*indices), vectors)
        # combine elements in the same column into the same tuple
        vectors = list(zip(*vectors))
        # remove the column we get but not needed
        vectors = vectors[:-1]

        drawLineChart(vectors, titles)


if __name__ == '__main__':
    main()
