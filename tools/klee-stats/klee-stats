#!/usr/bin/env python
# -*- encoding: utf-8 -*-

# ===-- klee-stats --------------------------------------------------------===##
# 
#                      The KLEE Symbolic Virtual Machine
# 
#  This file is distributed under the University of Illinois Open Source
#  License. See LICENSE.TXT for details.
# 
# ===----------------------------------------------------------------------===##

"""Output statistics logged by Klee."""

# use '/' to mean true division and '//' to mean floor division
from __future__ import division
from __future__ import print_function

import os
import re
import sys
import argparse
import ConfigParser

from operator import itemgetter
try:
    from tabulate import TableFormat, Line, DataRow, tabulate
except:
    print('Error: Package "tabulate" required for table formatting. '
          'Please install it using "pip" or your package manager.',
          file=sys.stderr)
    exit(1)

Legend = [
    ('Instrs', 'number of executed instructions'),
    ('Time', 'total wall time (s)'),
    ('TUser', 'total user time'),
    ('ICov', 'instruction coverage in the LLVM bitcode (%)'),
    ('BCov', 'branch coverage in the LLVM bitcode (%)'),
    ('ICount', 'total static instructions in the LLVM bitcode'),
    ('TSolver', 'time spent in the constraint solver'),
    ('States', 'number of currently active states'),
    ('Mem', 'megabytes of memory currently used'),
    ('Queries', 'number of queries issued to STP'),
    ('AvgQC', 'average number of query constructs per query'),
    ('Tcex', 'time spent in the counterexample caching code'),
    ('Tfork', 'time spent forking'),
    ('TResolve', 'time spent in object resolution'),
]

KleeTable = TableFormat(lineabove=Line("-", "-", "-", "-"),
                        linebelowheader=Line("-", "-", "-", "-"),
                        linebetweenrows=None,
                        linebelow=Line("-", "-", "-", "-"),
                        headerrow=DataRow("|", "|", "|"),
                        datarow=DataRow("|", "|", "|"),
                        padding=0,
                        with_header_hide=None)

#global config reader
Config = ConfigParser.ConfigParser()
#config file location
global ConfigFile
ConfigFile = os.path.join(sys.path[0], "default.config")

#updated upon reading config
global version
version = None

#for automatic version finding
global autoVersion
autoVersion = None

#hash for grouped variables
global groups
groups = {}

#Flags for postprocessing record
global topInstrs
topInstrs = None

def getLogFile(path):
    """Return the path to run.stats."""
    return os.path.join(path, 'run.stats')


class LazyEvalList:
    """Store all the lines in run.stats and eval() when needed."""
    def __init__(self, lines):

        firstLine = eval(lines[0])
        if isinstance(firstLine, tuple):
            #Preversioned, only remove one line
            # The first line in the records contains headers.
            self.lines = lines[1:]
        else:
            # The first line in the records contains version number
            # The second line in the records contains headers.
            self.lines = lines[2:]

        

    def __getitem__(self, index):
        if isinstance(self.lines[index], str):
            self.lines[index] = eval(self.lines[index])
        return self.lines[index]

    def __len__(self):
        return len(self.lines)


def getMatchedRecordIndex(records, column, target):
    """Find target from the specified column in records."""
    target = int(target)
    lo = 0
    hi = len(records) - 1
    while lo < hi:
        mid = (lo + hi) // 2
        if column(records[mid]) <= target:
            lo = mid + 1
        else:
            hi = mid
    return lo

def getColumnIndex(columnName):
    #Instead of using itemgetter
    recordFormat = config_value("Input", 'record')

    rlist = recordFormat.split(', ')
    index = -1
    for i,n in enumerate(rlist):
        if columnName == rlist[i]:
            index = i

    return index

def getColumnValues(columnName, records):
    index = getColumnIndex(columnName)
    if index is not -1:
        return list(map(itemgetter(index), records))
    else:
        print("ERROR: Cannot get column '%s' values" % columnName)
        sys.exit(1)

def aggregateRecords(records):
    stats = None
    if Config.has_section("Aggregates"):

        for option in Config.options("Aggregates"):
            equations = parse_list(config_value("Aggregates", option))
            for equation in equations:
                exec(equation)

        statstr = "stats = " + config_value("Aggregates", 'stats')
        try:  
            exec(statstr)
        except:
            print("ERROR: Check '%s' in section '%s'" % ("Input", 'stats'))
            sys.exit(1)


    return stats


def stripCommonPathPrefix(paths):
    paths = map(os.path.normpath, paths)
    paths = [p.split('/') for p in paths]
    zipped = zip(*paths)
    i = 0
    for i, elts in enumerate(zipped):
        if len(set(elts)) > 1:
            break
    return ['/'.join(p[i:]) for p in paths]


def getKeyIndex(key, labels):
    """Get the index of the specified key in labels."""
    def normalizeKey(key):
        return re.split('\W', key)[0]

    for i, title in enumerate(labels):
        if normalizeKey(title) == normalizeKey(key):
            return i
    else:
        raise ValueError('invalid key: {0}'.format(key))


def getKleeOutDirs(dirs):
    kleeOutDirs = []
    for dir in dirs:
        if os.path.exists(os.path.join(dir, 'info')):
            kleeOutDirs.append(dir)
        else:
            for root, subdirs, _ in os.walk(dir):
                for d in subdirs:
                    path = os.path.join(root, d)
                    if os.path.exists(os.path.join(path, 'info')):
                        kleeOutDirs.append(path)
    return kleeOutDirs

def postLabels(labels):
    #Post process labels
    global topInstrs

    #Post processing for intructions
    if topInstrs is not None and topInstrs[0] is not None:
        ll = list(labels)
        ll.append("Top Instr")
        labels = tuple(ll)

    return labels

def getLabels(pr):
    #Interpreting the input description from config file
    try:
        strLabel = "labels = " + config_value("Labels", pr+"_labels")   
        exec(strLabel)
    except:
        print("ERROR: Check '%s' in section '%s'" % (pr, 'labels'))
        sys.exit(1)
    return postLabels(labels)

def preRow(string):
    #For @ notation usage (expands into _)
    return string.replace('@','_')

def postRow(record, post):
    #Changes to the row after calculations take place

    #Post processing for intructions
    if topInstrs is not None and topInstrs[0] is not None:
        lr = list(record)
        if post is not None:
            lr.append(post)
        else:
            lr.append(" ")
        record = tuple(lr)
    return record

def getRow(record, stats, pr, post):
    #Interprets input format from config file
    recordstr = config_value("Input", 'record') + " = record"  
    try:  
        exec(recordstr)
    except:
        print("ERROR: Check '%s' in section '%s'" % ("record", 'Input'))
        sys.exit(1)

    if Config.has_section("Aggregates") and Config.has_option("Aggregates", 'stats'):
        statstr = config_value("Aggregates", 'stats') + " = stats"
        try:  
            exec(statstr)
        except:
            print("ERROR: Check '%s' in section '%s'" % ("record", 'Input'))
            sys.exit(1)

    #Line coverage hack
    if BTot == 0:
        BFull = BTot = 1

    #Mem = Mem / 1024 / 1024
    #AvgQC = int(QCon / max(1, QTot))

    #groups must be in left hand side of assignment
    global groups
    equations = []
    if Config.has_option("Calculations", pr):
        equations = parse_list(config_value("Calculations", pr))
    
    for i, equation in enumerate(equations):
        #lstrip to remove potential whitespace issues
        groupvar = (equation.split(' ')[0]).lstrip(" ")
        #@ used between groups
        gsplit = groupvar.split('@')

        try:
            if len(gsplit) == 1 or gsplit[1] not in groups:
                if gsplit[0][0] == '>':
                    #Import equations from other categories
                    category = gsplit[0][1:]
                    importEqs = parse_list(config_value("Calculations", category))
                    #Add equations after the current index, i.e. expand in place
                    equations[i+1:i+1] = importEqs
                else:
                    exec(equation)
            else:
                group = gsplit[1]
                #TODO: Make replace more robust
                for var in groups[group]:
                    subeq = equation.replace("@","_").replace(group, var)
                    exec(subeq)
        except:
            print("Error in calculation for '%s', please check contents of config file" % pr)
            print("Occurred on statement %s" % equation)
            sys.exit(1)
    
    #return formatted output tuble from config
    ret = eval(preRow(config_value("Output", pr)))
    return postRow(ret, post)

def drawLineChart(vectors, titles):
    """Draw a line chart based on data from vectors.

    Args:
        vectors: A list of vectors. Each vector is drawn in a separate
                 subchart.
        titles: A list of strings. Each string is an explanation of the
                corresponding vector.
    """
    try:
        import matplotlib
        matplotlib.use('Agg')  # plot without X-server connection
        import matplotlib.pyplot as plt
    except:
        print('Error: Package "matplotlib" required for figure plotting. '
              'Please install it using "pip" or your package manager.',
              file=sys.stderr)
        exit(1)
    from math import sqrt, ceil

    nFigs = len(vectors)       # number of subfigures
    nRow = int(sqrt(nFigs))    # number of rows in the figure
    nCol = ceil(nFigs / nRow)  # number of columns in the figure

    fig = plt.figure()
    for i in range(nFigs):
        ax = fig.add_subplot(nRow, nCol, i)
        ax.plot(vectors[i])
        ax.set_title(titles[i])
        #ax.set_xlabel()
        #ax.set_ylabel()

    #fig.show()
    #raw_input('Press any key to continue..')

    def getFileName():
        """Get a unused file name in current directory."""
        i = 0
        fileName = 'fig-klee-stats-{0}.png'.format(i)
        while os.path.exists(fileName):
            i = i + 1
            fileName = 'fig-klee-stats-{0}.png'.format(i)
        return fileName

    plt.savefig(getFileName(),
                dpi=150,  # dots-per-inch, default: 100
                bbox_inches='tight',  # tighter bbox
                transparent=False)

def open_config():
    global ConfigFile

    try:
        #Overriding config file in current working directory
        if(Config.read(os.path.join(os.getcwd(), "override.config"))):
            print("Override Config found in working directory")
            return True
        else:
            #Default Config
            return Config.read(ConfigFile)
    except:
        print("Error: Unable to read config file")
        sys.exit(1)
        return False

def config_value(section, option):
    if Config.has_option(section, option):
        return Config.get(section, option)
    else:
        print("Expected a %s value in section %s. Please check config file" % (option, section))
        sys.exit(1)

def parse_groups():
    global groups
    options = Config.options("Groups")
    for option in options:
        groups[option] = parse_list(config_value("Groups", option))

def parse_list(input):
    if input is not None:
        values = input.split(", ")
        for i, value in enumerate(values):
            values[i] = value.lstrip(' ')
        return values
    else:
        return []


def parse_config():
    global version

    if(open_config()):
        version = eval(config_value("Info", 'version'))
        parse_groups();
    else:
        print("ERROR: Config file could not be opened. Please check config file")
        print(ConfigFile)
        sys.exit(1)


def parse_control_args(pControl):
    # argument group for controlling output verboseness
    #Dynamic command line option generator
    for option in Config.options("Output"):
        if Config.has_option("Help", option):
            help = config_value("Help", option)
        else:
            help = "No help information provided"
        start = "'--print-%s', action='store_true', dest='p%s', help='%s'" % (option, option.capitalize(), help)
        
        line = "pControl.add_argument(%s)" % start

        exec(line)

def get_print_controls(args):
    pr = 'default'
    for option in Config.options("Output"):
        strargs = "args.p%s" % option.capitalize()
        if eval(strargs):
            pr = option
    return pr
        
def processVersions(versions):
    global version
    global autoVersion

    v = None
    for i, output_ver in enumerate(versions):
        if isinstance(output_ver, tuple):
            #Changing preversioned to be compatible
            versions[i] = 1

        if v is None:
            v = versions[i]
        else:
            if v != versions[i]:
                print("ERROR: Klee output files are inconsistent: %s and %s" % (v, versions[i]))
                sys.exit(1)

    if autoVersion and v != version:
        print("ERROR: Klee output files and config are inconsistent: %s and %s" % (v, version))
        sys.exit(1)
    elif v != version and not handle_version(v):
        #Error case for version file not being found
        print("ERROR: Specified config 'version-%s' could not be loaded automatically (Version detected from run.stats)" % v)
        sys.exit(1)

    return versions

def getVersionFilePath(config):
    try:
        #Version cases
        #Hack to prevent version-# from evaluating as it evaluates to 0 (?)
        longbool = (isinstance(config, int) or isinstance(config, float)) or \
            ((isinstance(eval(config), int) or isinstance(eval(config), float)) and eval(config) != 0)

        if longbool:
            config = "version-%s" % config
    except:
        pass

    filePath = "stat-configs/%s.config" % config
    return os.path.join(sys.path[0], filePath)

def preparse_cmdLine():
    #Preparsing allows selection of config file
    global ConfigFile
    global autoVersion

    #Custom version input
    v = sys.argv[1]

    #Check if v is a version, ie if a config file for it exists
    fullPath = getVersionFilePath(v)
    if os.path.isfile(fullPath):
        autoVersion = v
        #Starting with specific config version
        ConfigFile = fullPath
    

def handle_version(config):
    #Spawn new klee-stats with version specified
    fullPath = getVersionFilePath(config)
    if os.path.isfile(fullPath):
        flags = " "
        for arg in sys.argv[1:]:
            if "--config" not in arg:
                flags += arg + " "

        script = "klee-stats "
        cmd = script + str(config) + flags
        os.system(cmd)
        sys.exit(0)
        return True
    else:
        return False


#Istats functions
def enum(**enums):
    return type('Enum', (), enums)

StatFields = enum(AssemblyLine=0,
              FileLine=1,
              Covered=2,
              Forks=3,
              RealTime=4,
              UserTime=5,
              Instructions=6,
              MDU=7,
              ResolveTime=8,
              States=9,
              Uncovered=10,
              Queries=11)

def parseAssembly(assembly):
    """Parse an LLVM assembly file
    """

    def getInstruction(line):
        inst = ''
        if line.startswith('  '):
            line = line.lstrip()
            if line.startswith('%'):
                _, _, line = line.partition('=')
                line = line.lstrip()
                inst, _, _  = line.partition(' ')
            else:
                inst, _, _ = line.partition(' ')
            if inst == 'tail':
                inst = 'call'
        return inst

    insts = [getInstruction(line) for line in open(assembly)]
    uinsts = [i for i in set(insts) if i]
    ilmap = zip(uinsts, [[l + 1 for l, i in enumerate(insts) if i == ui] for ui in uinsts])
    return ilmap

def parseStats(stats):
    """Parse a klee-generated istats file
    
    """

    def getStats(line):
        stat = (0,(0, 0, 0))
        items = line.split()
        try:
            if len(items) > 4 and items[StatFields.Covered] == '1':
                line = int(items[StatFields.AssemblyLine])
                time = int(items[StatFields.RealTime])
                count = int(items[StatFields.Instructions])
                stat = (line, (time,count,time/count))
        except:
            pass
        return stat

    d = dict([getStats(line) for line in open(stats)])
    if 0 in d:
        del d[0]
    return d

def openLLIstats(cdir):
    assembly = os.path.join(cdir, 'assembly.ll')
    istats   = os.path.join(cdir, 'run.istats')
    if os.path.exists(assembly) and os.path.exists(istats):
        asdata = parseAssembly(assembly)
        stats = parseStats(istats)
    else:
        print('assembly.ll or run.istats no found', file=sys.stderr)
        exit(1)

    return asdata, stats

def topInstructions(cdir):
    asdata, stats = openLLIstats(cdir)

    itimes = [(inst, map(sum, zip(*[stats[l] for l in lines if l in stats])) ) for inst, lines in asdata]
    # Eliminate bogus instructions picked up by our imperfect LLVM IR parser
    itimes = [item for item in itimes if item[1]]
    validinst = set([item[0] for item in itimes])

    maxitimes = dict([(inst, max([stats[l][2] for l in lines if l in stats])) for inst, lines in asdata if inst in validinst])
    # Sort by real time
    itimes.sort(key=lambda x : x[1][0], reverse=True)

    #Hardcoded removal
    itimes = itimes[:10]

    return maxitimes, itimes

def main():
    # function for sanitizing arguments
    def isPositiveInt(value):
        try:
            value = int(value)
        except ValueError:
            raise argparse.ArgumentTypeError(
                'integer expected: {0}'.format(value))
        if value <= 0:
            raise argparse.ArgumentTypeError(
                'positive integer expected: {0}'.format(value))
        return value

    preparse_cmdLine()

    parse_config()

    parser = argparse.ArgumentParser(
        description='output statistics logged by klee',
        epilog='LEGEND\n' + tabulate(Legend),
        formatter_class=argparse.RawDescriptionHelpFormatter)

    parser.add_argument('--config', dest='config', metavar='name',
                        help='Specify the config file used'
                        ' (if none is specified it will try to use '
                        'the default or will automatically chose)')

    parser.add_argument('dir', nargs='+', help='klee output directory')

    parser.add_argument('--precision',
                        dest='precision', type=isPositiveInt,
                        default=2, metavar='n',
                        help='Floating point numbers display precision '
                        '(default: 2).')
    parser.add_argument('--table-format',
                        choices=['plain', 'simple', 'grid', 'pipe', 'orgtbl',
                                 'rst', 'mediawiki', 'latex', 'klee'],
                        dest='tableFormat', default='klee',
                        help='Table format for the summary.')
    parser.add_argument('--draw-line-chart',
                        dest='drawLineChart', metavar='header-list',
                        help='Draw line chart for a list of columns. '
                        'Columns must be chosen from the headers of the '
                        'table outputted and separated by comma (e.g., '
                        '--draw-line-chart=Instrs,Time). Data points '
                        'on x-axis correspond to lines in run.stats.')
    parser.add_argument('--sample-interval', dest='sampleInterv',
                        type=isPositiveInt, default='10', metavar='n',
                        help='Sample a data point every n lines for a '
                        'run.stats (default: 10)')

    parser.add_argument('--top-instructions',
                          action='store_true', dest='TI',
                          help='Show most expensive instruction per run.')

    # argument group for controlling output verboseness

    pControl = parser.add_mutually_exclusive_group(required=False)
    parse_control_args(pControl);

    # arguments for sorting
    parser.add_argument('--sort-by', dest='sortBy', metavar='header',
                        help='Key value to sort by. Must be chosen from '
                        'the headers of the table outputted  (e.g., '
                        '--sort-by=Instrs).')
    parser.add_argument('--ascending',
                        dest='ascending', action='store_true',
                        help='Sort in ascending order (default: False).')

    # arguments for comparing
    parser.add_argument('--compare-by', dest='compBy', metavar='header',
                        help='Key value on which to compare runs to the '
                        'reference one (which is the first one). Must be '
                        'chosen from the headers of the table oputputted. '
                        'e.g., --compare-by=I shows how each run '
                        'compares to the reference run after executing the '
                        'same number of instructions as the reference run. '
                        "If a run hasn't executed as many instructions as "
                        'the reference one, we simply print the statistics '
                        'at the end of that run. The key value for a given '
                        'column is its corresponding value in record in the '
                        'config')
    parser.add_argument('--compare-at', dest='compAt', metavar='value',
                        help='Value to compare the runs at. Can be special '
                        "value 'last' to compare at the last point which "
                        'makes sense. Use in conjunction with --compare-by.')

    args = parser.parse_args()

    #Handling config version selection
    if args.config and not handle_version(args.config):
        print("ERROR: Specified config '%s' could not be found" % args.config)
        sys.exit(1)

    pr = get_print_controls(args)

    dirs = getKleeOutDirs(args.dir)
    if len(dirs) == 0:
        print('no klee output dir found', file=sys.stderr)
        exit(1)
    # read contents from every run.stats file into LazyEvalList
    data = [LazyEvalList(list(open(getLogFile(d)))) for d in dirs]

    #Version list/configuration
    dataVs = processVersions([eval(list(open(getLogFile(d)))[0]) for d in dirs])



    if len(data) > 1:
        dirs = stripCommonPathPrefix(dirs)

    global topInstrs

    if args.TI:
       #istatsFile = os.path.join(sys.path[0], "istats")
       #execfile(istatsFile)

        # Get top inst
        _, test = topInstructions(dirs[0])
        idata = map(topInstructions, dirs)
        topInstrs = [itimes[0][0] for (maxitimes, itimes) in idata]

    labels = getLabels(pr)

    #To work with the zip
    if topInstrs is None:
        topInstrs = [None] * len(dirs)

        # attach the stripped path
    data = list(zip(dirs, data, topInstrs))

    # compBy now uses names given in the config file for column specification
    if args.compBy:
        # index in the record of run.stats
        compIndex = getColumnIndex(args.compBy)
        if compIndex == -1:
            print("ERROR: Invalid compare-by value")
            sys.exit(1)

        if args.compAt:
            if args.compAt == 'last':
                # [records][last-record][compare-by-index]
                refValue = min(map(lambda r: r[1][-1][compIndex], data))
            else:
                refValue = args.compAt
        else:
            refValue = data[0][1][-1][compIndex]

    # build the main body of the table
    table = []
    totRecords = []  # accumulated records
    totStats = []    # accumulated stats
    for path, records, post in data:
        row = [path]
        if args.compBy:
            matchIndex = getMatchedRecordIndex(
                records, itemgetter(compIndex), refValue)
            stats = aggregateRecords(LazyEvalList(records[:matchIndex + 1]))
            totStats.append(stats)
            row.extend(getRow(records[matchIndex], stats, pr, post))
            totRecords.append(records[matchIndex])
        else:
            stats = aggregateRecords(records)
            totStats.append(stats)
            row.extend(getRow(records[-1], stats, pr, post))
            totRecords.append(records[-1])
        table.append(row)
    # calculate the total
    totRecords = [sum(e) for e in zip(*totRecords)]
    if totStats.count(None) != len(totStats): #Optional stats
        totStats = [sum(e) for e in zip(*totStats)]
    totalRow = ['Total ({0})'.format(len(table))]
    totalRow.extend(getRow(totRecords, totStats, pr, None))

    if args.sortBy:
        table = sorted(table, key=itemgetter(getKeyIndex(args.sortBy, labels)),
                       reverse=(not args.ascending))

    if len(data) > 1:
        table.append(totalRow)
    table.insert(0, labels)

    if args.tableFormat != 'klee':
        print(tabulate(
            table, headers='firstrow',
            tablefmt=args.tableFormat,
            floatfmt='.{p}f'.format(p=args.precision),
            numalign='right', stralign='center'))
    else:
        stream = tabulate(
            table, headers='firstrow',
            tablefmt=KleeTable,
            floatfmt='.{p}f'.format(p=args.precision),
            numalign='right', stralign='center')
        # add a line separator before the total line
        if len(data) > 1:
            stream = stream.splitlines()
            stream.insert(-2, stream[-1])
            stream = '\n'.join(stream)
        print(stream)

    if args.drawLineChart:
        if len(dirs) != 1:
            print('--draw-line-chart only supports using a single file',
                  file=sys.stderr)
            exit(1)

        # sample according to the given interval
        samples = [r for i, r in enumerate(data[0][1])
                   if i % args.sampleInterv == 0]
        vectors = []
        for i in range(len(samples)):
            # aggregate all the samples upto the i-th one
            stats = aggregateRecords(samples[:i + 1])
            vectors.append(getRow(samples[i], stats, pr, None))

        titles = args.drawLineChart.split(',')
        # Index returned by getKeyIndex() against labels is starting from
        # 'Path' column.  vectors here doesn't have the 'Path' column.
        indices = [getKeyIndex(e, labels) - 1 for e in titles]
        # get one more column to make sure itemgetter always return tuples
        indices.append(0)
        # strip columns not specified by the user
        vectors = map(itemgetter(*indices), vectors)
        # combine elements in the same column into the same tuple
        vectors = list(zip(*vectors))
        # remove the column we get but not needed
        vectors = vectors[:-1]

        drawLineChart(vectors, titles)


if __name__ == '__main__':
    main()
