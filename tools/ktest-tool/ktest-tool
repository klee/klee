#!/usr/bin/env python

# ===-- ktest-tool --------------------------------------------------------===##
# 
#                      The KLEE Symbolic Virtual Machine
# 
#  This file is distributed under the University of Illinois Open Source
#  License. See LICENSE.TXT for details.
# 
# ===----------------------------------------------------------------------===##

import os
import struct
import sys
import re
import json
import itertools as it

version_no=3
type_meta_filename='type-meta.kmeta'
python_version=sys.version_info[0]

class KTestError(Exception):
    pass

class KMeta:
    def __init__(self, metaInfos, byteOrder):
        self.metaInfos = metaInfos
        self.byteOrder = byteOrder

    @staticmethod
    def fromfile(path):
        metaPath = os.path.join(os.path.dirname(path), type_meta_filename)
        if not os.path.exists(metaPath):
            return False
        metaInfos = dict()
        with open(metaPath, "r") as file:
            byteOrder = file.readline()
            if (python_version < 3):
                file_lines_by_two = it.izip_longest(*[file]*2)
            else:
                file_lines_by_two = it.zip_longest(*[file]*2)
            for name,typeMeta in file_lines_by_two:
                if name and typeMeta:
                    metaInfos[str(name).strip('\n\r\0')] = str(typeMeta).strip('\n\r\0')
        kmeta = KMeta(metaInfos, byteOrder)
        return kmeta

    def getType(self, name):
        return self.metaInfos.get(name, None)

    @staticmethod
    def getUnpackString(typeMeta, count=1, recurs=1):
        if recurs > 3:
            return "no deeper"
        metas = typeMeta.split(':')
        unpackStr = ''
        if metas[0] == 'int':
            bitWidth = int(metas[1])
            # TODO could not extract sign information from llvm, that is missing currently
            if (bitWidth == 2):
                unpackStr = str(count) + 'h'
            elif (bitWidth == 4):
                unpackStr = str(count) + 'i'
            elif (bitWidth == 8):
                unpackStr = str(count) + 'q'
        elif metas[0] == 'array':
            unpackStr = KMeta.getUnpackString(typeMeta[typeMeta.find(metas[2]):],
                                              int(metas[1]), recurs + 1)
        elif metas[0] == 'char':
            unpackStr = str(count) + 'c'
        #TODO other types as well
        elif metas[0] == 'double':
            unpackStr = 'unhandled'
        elif metas[0] == 'float':
            unpackStr = 'unhandled'
        elif metas[0] == 'unhandled':
            return 'unhandled'
        else:
            return 'unhandled'
        return unpackStr

    @staticmethod
    def formatData(type, extractedData):
        formattedData = {}
        typeMeta = type.split(':')
        typeName = typeMeta[0]
        if typeName == 'array':
            arrayName = 'array(' + typeMeta[2] + ')[' + typeMeta[1] + ']'
            formattedData[arrayName] = [] 
            if (typeMeta[2] == 'char'):
                for elem in extractedData:
                    formattedData[arrayName].append(elem.decode('utf-8'))
            else:
                for elem in extractedData:
                    formattedData[arrayName].append(elem)
        else:
            if typeName == 'char':
                formattedData[typeName] = extractedData[0].decode('utf-8')
            else:
                formattedData[typeName] = extractedData[0]
        return formattedData



    @staticmethod
    def extractData(typeMeta, data, byteOrder, offset=0):
        if byteOrder == 'big':
            byteOrder = '>'
        else:
            byteOrder = '<'
        metas = typeMeta.split(':')
        if metas[0] == 'struct':
            currentStruct = {}
            structName = metas[1]
            currentStruct[structName] = []
            typeMeta = re.sub('###$', '', typeMeta)
            types = typeMeta[typeMeta.find(metas[1])+len(metas[1])+1:].split(">>>")
            i = 0
            while i < len(types):
                typ = types[i]
                metaChunks = typ.split(':')
                if (metaChunks[0] == 'struct'):
                    currOffset = offset
                    j = -1
                    for j in reversed(range(len(types))):
                        if '###' in types[j]:
                            currMetaChunks = types[j].split(':')
                            currOffset = int(currMetaChunks[-1])
                            break
                    lowerTypeMeta = re.sub('[^#]+$', '', '>>>'.join(types[i:j+1]))
                    i = j + 1
                    currentStruct[structName].append(KMeta.extractData(lowerTypeMeta, data, byteOrder, offset + currOffset))
                    continue
                unpackStr = KMeta.getUnpackString(typ)
                if (unpackStr != 'unhandled'):
                    extractedData = struct.unpack_from(byteOrder + unpackStr,
                                                   data, int(metaChunks[-1]) + offset)
                    currentStruct[structName].append(KMeta.formatData(typ, extractedData))
                else:
                    currentStruct[structName].append('unhandled')
                i += 1
            return currentStruct
        else:
            unpackStr = KMeta.getUnpackString(typeMeta)
            if unpackStr != 'unhandled':
                extractedData = struct.unpack(byteOrder + unpackStr, data)
                return KMeta.formatData(typeMeta, extractedData)
            else:
                return 'unhandled'

class KTest:
    @staticmethod
    def fromfile(path):
        if not os.path.exists(path):
            print("ERROR: file %s not found" % (path))
            sys.exit(1)
            
        f = open(path,'rb')
        hdr = f.read(5)
        if len(hdr)!=5 or (hdr!=b'KTEST' and hdr != b"BOUT\n"):
            raise KTestError('unrecognized file')
        version, = struct.unpack('>i', f.read(4))
        if version > version_no:
            raise KTestError('unrecognized version')
        numArgs, = struct.unpack('>i', f.read(4))
        args = []
        for i in range(numArgs):
            size, = struct.unpack('>i', f.read(4))
            args.append(str(f.read(size).decode(encoding='ascii')))
            
        if version >= 2:
            symArgvs, = struct.unpack('>i', f.read(4))
            symArgvLen, = struct.unpack('>i', f.read(4))
        else:
            symArgvs = 0
            symArgvLen = 0

        numObjects, = struct.unpack('>i', f.read(4))
        objects = []
        for i in range(numObjects):
            size, = struct.unpack('>i', f.read(4))
            name = f.read(size)
            size, = struct.unpack('>i', f.read(4))
            bytes = f.read(size)
            objects.append( (name,bytes) )

        # Create an instance
        b = KTest(version, args, symArgvs, symArgvLen, objects)
        # Augment with extra filename field
        b.filename = path
        return b
    
    def __init__(self, version, args, symArgvs, symArgvLen, objects):
        self.version = version
        self.symArgvs = symArgvs
        self.symArgvLen = symArgvLen
        self.args = args
        self.objects = objects

        # add a field that represents the name of the program used to
        # generate this .ktest file:
        program_full_path = self.args[0]
        program_name = os.path.basename(program_full_path)
        # sometimes program names end in .bc, so strip them
        if program_name.endswith('.bc'):
          program_name = program_name[:-3]
        self.programName = program_name
        
def trimZeros(str):
    for i in range(len(str))[::-1]:
        if str[i] != '\x00':
            return str[:i+1]
    return ''

def printFileInfos(file, b):
    print('ktest file : %r' % file)
    print('args       : %r' % b.args)
    print('num objects: %r' % len(b.objects))

def printObjectRegularly(i, name, data, opts):
    if opts.trimZeros:
        str = trimZeros(data)
    else:
        str = data

    print('object %4d: name: %r' % (i, name))
    print('object %4d: size: %r' % (i, len(data)))
    if opts.writeInts and len(data) == 4: 
        print('object %4d: data: %r' % (i, struct.unpack('i',str)[0]))
    else:
        print('object %4d: data: %r' % (i, str))


def printRegularly(file, opts):
    b = KTest.fromfile(file)
    pos = 0
    printFileInfos(file, b)
    for i,(name,data) in enumerate(b.objects):
        printObjectRegularly(i, name, data, opts)
        if i < len(b.objects) - 1:
            print('')

def printBeautifully(file, opts):
    m = KMeta.fromfile(file)
    if not m:
        print('Could not find type meta informations to beautify')
        printRegularly(file, opts)
        return
    b = KTest.fromfile(file)
    printFileInfos(file, b)
    for i,(name,data) in enumerate(b.objects):
        #TODO python 2 vs 3, currently works with python 3
        typeMeta = m.getType(name.decode('utf-8').strip('\n\r\0'))
        if typeMeta:
            print('object %4d: name: %s' % (i, name.decode('utf-8')))
            print('object %4d: size: %r' % (i, len(data)))
            print('object %4d: data:\n%s' % (i, json.dumps(KMeta.extractData(typeMeta,
                                                               data, m.byteOrder), indent=2)))
        else:
            printObjectRegularly(i, name, data, opts)
        if i < len(b.objects) - 1:
            print('')


    
def main(args):
    from optparse import OptionParser
    op = OptionParser("usage: %prog [options] files")
    op.add_option('','--trim-zeros', dest='trimZeros', action='store_true', 
                  default=False,
                  help='trim trailing zeros')
    op.add_option('','--write-ints', dest='writeInts', action='store_true',
                  default=False,
                  help='convert 4-byte sequences to integers')
    op.add_option('', '--beautify', dest='beautify', action='store_true',
                  default=False,
                  help='try to make the output more readable ' +
                       '(this ignores any other arguments)')
    
    opts,args = op.parse_args()
    if not args:
        op.error("incorrect number of arguments")

    for i,file in enumerate(args):
        if opts.beautify:
            printBeautifully(file, opts)
        else:
            printRegularly(file, opts)
        if i < len(args) - 1:
            print('')
if __name__=='__main__':
    main(sys.argv)
